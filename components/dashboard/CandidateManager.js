import { useCallback, useEffect, useMemo, useState } from 'react';
import styles from '../../styles/AdminDataManager.module.css';
import { useToast } from '../ToastProvider';

const FULL_ACCESS_ROLES = new Set(['superadmin', 'hr_admin', 'hr', 'admin', 'marketer', 'marketing_admin', 'simple_user']);
const READ_ACCESS_ROLES = new Set(['superadmin', 'hr_admin', 'hr', 'admin', 'marketer', 'marketing_admin', 'simple_user']);

const ONBOARD_STATUS_OPTIONS = [
  { value: 'pending', label: 'Pending' },
  { value: 'reviewing', label: 'Reviewing' },
  { value: 'approved', label: 'Approved' },
  { value: 'rejected', label: 'Rejected' },
  { value: 'onboarded', label: 'Onboarded' },
];

const SERVICE_TYPE_OPTIONS = [
  { value: '', label: 'Select service type' },
  { value: 'plumbing', label: 'Plumbing' },
  { value: 'hvac', label: 'HVAC' },
  { value: 'restoration', label: 'Restoration' },
  { value: 'electrician', label: 'Electrician' },
  { value: 'roofing', label: 'Roofing' },
  { value: 'landscaping', label: 'Landscaping' },
  { value: 'other', label: 'Other' },
];

const INITIAL_FORM_STATE = {
  candidate_id: '',
  vendor_id: '',
  source_system: '',
  source_ref: '',
  name: '',
  email: '',
  phone: '',
  company_name: '',
  service_type: '',
  sub_service: '',
  service_area: '',
  address_street: '',
  address_unit: '',
  address_city: '',
  address_postal: '',
  address_province: '',
  address_country: 'CA',
  onboard_status: 'pending',
  notes: '',
};

function normalizeRole(role) {
  return typeof role === 'string' ? role.trim().toLowerCase() : '';
}

function hasFullAccess(user) {
  if (!user) return false;
  return FULL_ACCESS_ROLES.has(normalizeRole(user?.role));
}

function hasReadAccess(user) {
  if (!user) return false;
  const role = normalizeRole(user?.role);
  // Exclude base_user from access
  if (role === 'base_user') return false;
  return hasFullAccess(user) || READ_ACCESS_ROLES.has(role);
}

function formatDateTime(value) {
  if (!value) return '—';
  const date = value instanceof Date ? value : new Date(value);
  if (Number.isNaN(date.getTime())) return '—';
  return date.toLocaleString();
}

function preparePayload(formState, { isUpdate = false } = {}) {
  const payload = {};

  Object.entries(formState).forEach(([key, value]) => {
    if (value === '' || value === null || typeof value === 'undefined') {
      return;
    }

    // Handle nested address fields
    if (key.startsWith('address_')) {
      if (!payload.address) {
        payload.address = {};
      }
      const addressKey = key.replace('address_', '');
      payload.address[addressKey] = value.trim();
      return;
    }

    payload[key] = typeof value === 'string' ? value.trim() : value;
  });

  // Clean up address object - remove empty fields
  if (payload.address && typeof payload.address === 'object') {
    Object.keys(payload.address).forEach((key) => {
      const value = payload.address[key];
      if (!value || (typeof value === 'string' && value.trim() === '')) {
        delete payload.address[key];
      }
    });
    // Remove address object if it's now empty
    if (Object.keys(payload.address).length === 0) {
      delete payload.address;
    }
  }

  // Frontend validation (candidate_id will be auto-generated by backend if not provided)
  if (!isUpdate && !payload.source_system) {
    throw new Error('Source system is required');
  }
  if (!isUpdate && !payload.service_type) {
    throw new Error('Service type is required');
  }

  // Remove empty strings for optional fields to avoid validation issues
  Object.keys(payload).forEach((key) => {
    // Skip address object (already cleaned)
    if (key === 'address') return;
    // Remove empty strings and null values
    if (payload[key] === '' || payload[key] === null || payload[key] === undefined) {
      delete payload[key];
    }
  });

  return payload;
}

export default function CandidateManager({ user }) {
  const toast = useToast();
  const canRead = useMemo(() => hasReadAccess(user), [user]);
  const canEdit = useMemo(() => hasFullAccess(user), [user]);

  const [candidates, setCandidates] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [statusMessage, setStatusMessage] = useState('');
  const [formState, setFormState] = useState(INITIAL_FORM_STATE);
  const [editingCandidateId, setEditingCandidateId] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const loadCandidates = useCallback(async () => {
    if (!canRead) return;
    setIsLoading(true);
    setError('');
    try {
      const response = await fetch('/api/candidates?limit=100', {
        method: 'GET',
        credentials: 'include',
      });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok || payload.success === false) {
        const message = payload?.message || 'Failed to load candidates';
        throw new Error(message);
      }
      const data = payload?.data?.items || [];
      setCandidates(Array.isArray(data) ? data : []);
    } catch (err) {
      setError(err.message || 'Unable to load candidates');
      setCandidates([]);
    } finally {
      setIsLoading(false);
    }
  }, [canRead]);

  useEffect(() => {
    if (!canRead) return;
    loadCandidates();
  }, [canRead, loadCandidates]);

  const resetForm = useCallback(() => {
    setFormState(INITIAL_FORM_STATE);
    setEditingCandidateId('');
    setStatusMessage('');
    setError('');
  }, []);

  const handleInputChange = useCallback((event) => {
    const { name, value } = event.target;
    setFormState((prev) => ({
      ...prev,
      [name]: value,
    }));
  }, []);

  const handleEdit = useCallback(
    (candidate) => {
      if (!canEdit) return;
      setEditingCandidateId(candidate.candidate_id);
      setFormState({
        candidate_id: candidate.candidate_id || '',
        vendor_id: candidate.vendor_id || '',
        source_system: candidate.source_system || '',
        source_ref: candidate.source_ref || '',
        name: candidate.name || '',
        email: candidate.email || '',
        phone: candidate.phone || '',
        company_name: candidate.company_name || '',
        service_type: candidate.service_type || '',
        sub_service: candidate.sub_service || '',
        service_area: candidate.service_area || '',
        address_street: candidate.address?.street || '',
        address_unit: candidate.address?.unit || '',
        address_city: candidate.address?.city || '',
        address_postal: candidate.address?.postal_code || '',
        address_province: candidate.address?.province || '',
        address_country: candidate.address?.country || 'CA',
        onboard_status: candidate.onboard_status || 'pending',
        notes: candidate.notes || '',
      });
      setStatusMessage('');
      setError('');
    },
    [canEdit]
  );

  const handleDelete = useCallback(
    async (candidateId) => {
      if (!canEdit) return;
      if (!confirm('Are you sure you want to delete this candidate?')) return;

      try {
        const response = await fetch(`/api/candidates/${candidateId}`, {
          method: 'DELETE',
          credentials: 'include',
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok || payload.success === false) {
          throw new Error(payload?.message || 'Failed to delete candidate');
        }
        toast.success('Candidate deleted successfully');
        await loadCandidates();
        if (editingCandidateId === candidateId) {
          resetForm();
        }
      } catch (err) {
        toast.error(err.message || 'Failed to delete candidate');
      }
    },
    [canEdit, loadCandidates, editingCandidateId, resetForm, toast]
  );

  const handleSubmit = useCallback(
    async (event) => {
      event.preventDefault();
      if (!canEdit) return;
      setIsSubmitting(true);
      setStatusMessage('');
      setError('');
      try {
        const payload = preparePayload(formState, { isUpdate: Boolean(editingCandidateId) });
        const method = editingCandidateId ? 'PUT' : 'POST';
        const url = editingCandidateId
          ? `/api/candidates/${encodeURIComponent(editingCandidateId)}`
          : '/api/candidates';
        const response = await fetch(url, {
          method,
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await response.json().catch(() => ({}));
        if (!response.ok || data.success === false) {
          // Get detailed error message
          let errorMessage = data?.message || data?.error || 
            (editingCandidateId ? 'Failed to update candidate' : 'Failed to create candidate');
          
          // If error is an object or array, stringify it
          if (typeof errorMessage === 'object') {
            errorMessage = JSON.stringify(errorMessage);
          }
          
          // Include error details if available
          if (data?.error && typeof data.error !== 'string') {
            errorMessage += ': ' + JSON.stringify(data.error);
          }
          
          throw new Error(errorMessage);
        }
        toast.success(
          editingCandidateId ? 'Candidate updated successfully' : 'Candidate created successfully'
        );
        await loadCandidates();
        resetForm();
      } catch (err) {
        const errorMessage = err.message || 'Unable to submit candidate';
        setError(errorMessage);
        toast.error(errorMessage);
      } finally {
        setIsSubmitting(false);
      }
    },
    [canEdit, editingCandidateId, formState, loadCandidates, resetForm, toast]
  );

  if (!canRead) {
    return (
      <div className={styles.container}>
        <h2 className={styles.heading}>Candidates</h2>
        <div className={styles.feedback + ' ' + styles.feedbackError}>
          You do not have permission to view candidates.
        </div>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <div className={styles.header}>
        <div className={styles.headingGroup}>
          <h2 className={styles.heading}>Candidates</h2>
          <p className={styles.subtitle}>
            Manage candidate and vendor lead intake. Track onboarding status and service information.
          </p>
        </div>
        <div className={styles.headerMeta}>
          {canEdit && (
            <button
              type="button"
              className={styles.secondaryButton}
              onClick={resetForm}
              disabled={isSubmitting}
            >
              New Candidate
            </button>
          )}
        </div>
      </div>

      {statusMessage && (
        <div className={styles.feedback + ' ' + styles.feedbackSuccess}>{statusMessage}</div>
      )}
      {error && <div className={styles.feedback + ' ' + styles.feedbackError}>{error}</div>}

      {isLoading && (
        <div className={styles.feedback} style={{ textAlign: 'center' }}>
          Loading candidates...
        </div>
      )}

      {!isLoading && candidates.length === 0 && (
        <div className={styles.feedback} style={{ textAlign: 'center' }}>
          No candidates found.
        </div>
      )}

      {!isLoading && candidates.length > 0 && (
        <div className={styles.tableWrapper}>
          <table className={styles.table}>
            <thead>
              <tr>
                <th>Candidate ID</th>
                <th>Name</th>
                <th>Company</th>
                <th>Service Type</th>
                <th>Service Area</th>
                <th>Status</th>
                <th>Source</th>
                <th>Created</th>
                {canEdit && <th>Actions</th>}
              </tr>
            </thead>
            <tbody>
              {candidates.map((candidate) => (
                <tr key={candidate.candidate_id}>
                  <td>{candidate.candidate_id}</td>
                  <td>{candidate.name || '—'}</td>
                  <td>{candidate.company_name || '—'}</td>
                  <td>
                    {candidate.service_type}
                    {candidate.sub_service && ` (${candidate.sub_service})`}
                  </td>
                  <td>{candidate.service_area || '—'}</td>
                  <td>
                    <span
                      className={styles.statusBadge}
                      style={{
                        backgroundColor:
                          candidate.onboard_status === 'onboarded'
                            ? 'rgba(16, 185, 129, 0.1)'
                            : candidate.onboard_status === 'approved'
                            ? 'rgba(59, 130, 246, 0.1)'
                            : candidate.onboard_status === 'rejected'
                            ? 'rgba(239, 68, 68, 0.1)'
                            : 'rgba(148, 163, 184, 0.1)',
                        color:
                          candidate.onboard_status === 'onboarded'
                            ? '#10b981'
                            : candidate.onboard_status === 'approved'
                            ? '#3b82f6'
                            : candidate.onboard_status === 'rejected'
                            ? '#ef4444'
                            : '#64748b',
                      }}
                    >
                      {candidate.onboard_status || 'pending'}
                    </span>
                  </td>
                  <td>{candidate.source_system || '—'}</td>
                  <td>{formatDateTime(candidate.created_at)}</td>
                  {canEdit && (
                    <td>
                      <div className={styles.actionButtons}>
                        <button
                          type="button"
                          className={styles.editButton}
                          onClick={() => handleEdit(candidate)}
                          disabled={isSubmitting}
                        >
                          Edit
                        </button>
                        <button
                          type="button"
                          className={styles.deleteButton}
                          onClick={() => handleDelete(candidate.candidate_id)}
                          disabled={isSubmitting}
                        >
                          Delete
                        </button>
                      </div>
                    </td>
                  )}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}

      {canEdit && (
        <form className={styles.form} onSubmit={handleSubmit}>
          <h3 className={styles.formTitle}>
            {editingCandidateId ? 'Edit Candidate' : 'Create New Candidate'}
          </h3>
          <div className={styles.formGrid}>
            <label className={styles.formField}>
              <span>Candidate ID *</span>
              <input
                type="text"
                name="candidate_id"
                value={formState.candidate_id}
                onChange={handleInputChange}
                required={!editingCandidateId}
                disabled={Boolean(editingCandidateId)}
                placeholder="candidate_uuid or leave blank to auto-generate"
              />
            </label>

            <label className={styles.formField}>
              <span>Vendor ID</span>
              <input
                type="text"
                name="vendor_id"
                value={formState.vendor_id}
                onChange={handleInputChange}
                placeholder="Link to existing vendor"
              />
            </label>

            <label className={styles.formField}>
              <span>Source System *</span>
              <input
                type="text"
                name="source_system"
                value={formState.source_system}
                onChange={handleInputChange}
                required
                placeholder="partner_name_or_form"
              />
            </label>

            <label className={styles.formField}>
              <span>Source Ref</span>
              <input
                type="text"
                name="source_ref"
                value={formState.source_ref}
                onChange={handleInputChange}
                placeholder="External reference ID"
              />
            </label>

            <label className={styles.formField}>
              <span>Name</span>
              <input
                type="text"
                name="name"
                value={formState.name}
                onChange={handleInputChange}
                placeholder="Contact name"
              />
            </label>

            <label className={styles.formField}>
              <span>Email</span>
              <input
                type="email"
                name="email"
                value={formState.email}
                onChange={handleInputChange}
                placeholder="email@example.com"
              />
            </label>

            <label className={styles.formField}>
              <span>Phone</span>
              <input
                type="text"
                name="phone"
                value={formState.phone}
                onChange={handleInputChange}
                placeholder="+14165551234 (E.164)"
              />
            </label>

            <label className={styles.formField}>
              <span>Company Name</span>
              <input
                type="text"
                name="company_name"
                value={formState.company_name}
                onChange={handleInputChange}
                placeholder="Company or legal name"
              />
            </label>

            <label className={styles.formField}>
              <span>Service Type *</span>
              <select name="service_type" value={formState.service_type} onChange={handleInputChange} required>
                {SERVICE_TYPE_OPTIONS.map((option) => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
            </label>

            <label className={styles.formField}>
              <span>Sub Service</span>
              <input
                type="text"
                name="sub_service"
                value={formState.sub_service}
                onChange={handleInputChange}
                placeholder="e.g., high-voltage-electrician"
              />
            </label>

            <label className={styles.formField}>
              <span>Service Area</span>
              <input
                type="text"
                name="service_area"
                value={formState.service_area}
                onChange={handleInputChange}
                placeholder="e.g., Calgary, AB"
              />
            </label>

            <label className={styles.formField}>
              <span>Onboard Status</span>
              <select
                name="onboard_status"
                value={formState.onboard_status}
                onChange={handleInputChange}
              >
                {ONBOARD_STATUS_OPTIONS.map((option) => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
            </label>

            <label className={styles.formField} style={{ gridColumn: '1 / -1' }}>
              <span>Address Street</span>
              <input
                type="text"
                name="address_street"
                value={formState.address_street}
                onChange={handleInputChange}
              />
            </label>

            <label className={styles.formField}>
              <span>Address Unit</span>
              <input
                type="text"
                name="address_unit"
                value={formState.address_unit}
                onChange={handleInputChange}
              />
            </label>

            <label className={styles.formField}>
              <span>City</span>
              <input type="text" name="address_city" value={formState.address_city} onChange={handleInputChange} />
            </label>

            <label className={styles.formField}>
              <span>Postal Code</span>
              <input
                type="text"
                name="address_postal"
                value={formState.address_postal}
                onChange={handleInputChange}
              />
            </label>

            <label className={styles.formField}>
              <span>Province</span>
              <input
                type="text"
                name="address_province"
                value={formState.address_province}
                onChange={handleInputChange}
              />
            </label>

            <label className={styles.formField}>
              <span>Country</span>
              <input
                type="text"
                name="address_country"
                value={formState.address_country}
                onChange={handleInputChange}
              />
            </label>

            <label className={styles.formField} style={{ gridColumn: '1 / -1' }}>
              <span>Notes</span>
              <textarea
                name="notes"
                value={formState.notes}
                onChange={handleInputChange}
                rows={3}
                placeholder="Additional notes about this candidate"
              />
            </label>
          </div>
          <div className={styles.editActions}>
            <button type="submit" className={styles.primaryButton} disabled={isSubmitting}>
              {editingCandidateId ? 'Update Candidate' : 'Create Candidate'}
            </button>
            <button
              type="button"
              className={styles.secondaryButton}
              onClick={resetForm}
              disabled={isSubmitting}
            >
              Cancel
            </button>
          </div>
        </form>
      )}
    </div>
  );
}

